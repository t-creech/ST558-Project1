[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project 1",
    "section": "",
    "text": "#Project Introduction In this project, we will be implementing data processing and summarization functions on data that is pulled from the PUMS Census API!",
    "crumbs": [
      "Home",
      "Project 1"
    ]
  },
  {
    "objectID": "pages/data_summarization.html",
    "href": "pages/data_summarization.html",
    "title": "Data Summarization",
    "section": "",
    "text": "Functions",
    "crumbs": [
      "Home",
      "Data Summarization"
    ]
  },
  {
    "objectID": "pages/data_processing.html",
    "href": "pages/data_processing.html",
    "title": "Data Processing",
    "section": "",
<<<<<<< HEAD
    "text": "Before we get to writing any functions that we use, let’s make sure that we load in the necessary packages we need. We can also include some handy code that searches for the package and installs it in the event that it is not already installed on the device that is running the code.\n\n# We will need the tidyverse and tidycensus packages for this part of the project\n\n# Require will load the package if available and return FALSE if not available by adding the ! we will return TRUE if the package is not available, running the code in the if statement\nif(!require(tidyverse)){\n    # If package is not available, install it then load it again\n    install.packages(\"tidyverse\")\n    library(tidyverse)\n}\n\nLoading required package: tidyverse\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# Does same as above for other packages\nif(!require(httr)){\n    install.packages(\"httr\")\n    library(httr)\n}\n\nLoading required package: httr\n\nif(!require(jsonlite)){\n    install.packages(\"jsonlite\")\n    library(jsonlite)\n}\n\nLoading required package: jsonlite\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten",
=======
    "text": "Before we get to writing any functions that we use, let’s make sure that we load in the necessary packages we need. We can also include some handy code that searches for the package and installs it in the event that it is not already installed on the device that is running the code.\n\n# We will need the tidyverse and tidycensus packages for this part of the project\n\n# Require will load the package if available and return FALSE if not available by adding the ! we will return TRUE if the package is not available, running the code in the if statement\nif(!require(tidyverse)){\n    # If package is not available, install it then load it again\n    install.packages(\"tidyverse\")\n    library(tidyverse)\n}\n\nLoading required package: tidyverse\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# Does same as above for other packages\nif(!require(httr)){\n    install.packages(\"httr\")\n    library(httr)\n}\n\nLoading required package: httr\n\nif(!require(jsonlite)){\n    install.packages(\"jsonlite\")\n    library(jsonlite)\n}\n\nLoading required package: jsonlite\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nif(!require(dplyr)){\n    install.packages(\"dplyr\")\n    library(dplyr)\n}",
>>>>>>> b6c1596b5a025d25281a3e1f050b5a8b2f458eb1
    "crumbs": [
      "Home",
      "Data Processing"
    ]
  },
  {
    "objectID": "pages/data_processing.html#helper-functions",
    "href": "pages/data_processing.html#helper-functions",
    "title": "Data Processing",
    "section": "Helper Functions",
<<<<<<< HEAD
    "text": "Helper Functions\nFirst, let’s work to get the API working and just getting it to return any data. We can do this by writing a function that we will call “basic_data” that queries the API using a URL from the example list and checking the response code. To help us later, the function will also print the first level of the JSON if the function call is successful, and return TRUE if successful and FALSE if not.\n\n# Function that uses the example URL to check status of API to ensure data is being retrieved\nresponse_test &lt;- function(example_url) {\n  \n  # Save response as variable\n  response &lt;- httr::GET(example_url)\n  \n  # Get the status code of the response\n  status &lt;- status_code(response)\n  \n  # 200 is expected if working so if it is 200 print that it is working and invisibly return the response\n  if (status == 200) {\n    print(\"API working as expected\")\n    str(response, max.level = 1)\n    invisible(response)}\n  \n  # If not working, print as such and return FALSE\n  else {\n    print(paste(\"API not working. Status Code:\", status))\n    return(FALSE)}\n}\n\nNow that we have built a function that can test whether the API call is working as expected and provides us with some helpful details and functionality, let’s dive into some of the further data processing steps. Our first task is going to be to build a helper function that takes the data from the API call and turns it into a tibble. From testing our response_test function (see below), we can see that the data we are interested in is included in the content field, so we will use this field and the functionalities of jsonlite to turn this into a tibble. Upon testing the code, it appears that just taking the parsed data and converting it to a tibble leave the headers in the first row of the tibble. To overcome this, we will specifically identify the headers and the data to build the tibble. We can also go ahead and type convert the data in the tibble to coerce data types.\n\n# Function that takes the response from the API call and turns it into a tibble.\njson_to_tibble &lt;- function(resp) {\n  parsed &lt;- fromJSON(rawToChar(resp$content))\n  \n  # First row headers so save those as variable\n  headers &lt;- parsed[1, , drop = TRUE]\n  \n  # Rest is data so save that as such\n  resp_data &lt;- parsed[-1, , drop = FALSE]\n  \n  # Convert to tibble, naming columns\n  data_tibble &lt;- as_tibble(resp_data)\n  names(data_tibble) &lt;- headers\n  \n  # Convert to correct column types\n  # data_tibble &lt;- type_convert(data_tibble)\n  return(data_tibble)\n}",
=======
    "text": "Helper Functions\nFirst, let’s work to get the API working and just getting it to return any data. We can do this by writing a function that we will call “basic_data” that queries the API using a URL from the example list and checking the response code. To help us later, the function will also print the first level of the JSON if the function call is successful, and return TRUE if successful and FALSE if not.\n\n# Function that uses the example URL to check status of API to ensure data is being retrieved\nresponse_test &lt;- function(example_url) {\n  \n  # Save response as variable\n  response &lt;- httr::GET(example_url)\n  \n  # Get the status code of the response\n  status &lt;- status_code(response)\n  \n  # 200 is expected if working so if it is 200 print that it is working and invisibly return the response\n  if (status == 200) {\n    print(\"API working as expected\")\n    str(response, max.level = 1)\n    invisible(response)}\n  \n  # If not working, print as such and return FALSE\n  else {\n    print(paste(\"API not working. Status Code:\", status))\n    return(FALSE)}\n}\n\nNow that we have built a function that can test whether the API call is working as expected and provides us with some helpful details and functionality, let’s dive into some of the further data processing steps. Our first task is going to be to build a helper function that takes the data from the API call and turns it into a tibble. From testing our response_test function (see below), we can see that the data we are interested in is included in the content field, so we will use this field and the functionalities of jsonlite to turn this into a tibble. Upon testing the code, it appears that just taking the parsed data and converting it to a tibble leave the headers in the first row of the tibble. To overcome this, we will specifically identify the headers and the data to build the tibble. We can also go ahead and type convert the data in the tibble to coerce data types.\n\n# Function that takes the response from the API call and turns it into a tibble.\njson_to_tibble &lt;- function(resp) {\n  parsed &lt;- fromJSON(rawToChar(resp$content))\n  \n  # First row headers so save those as variable\n  headers &lt;- parsed[1, , drop = TRUE]\n  \n  # Rest is data so save that as such\n  resp_data &lt;- parsed[-1, , drop = FALSE]\n  \n  # Convert to tibble, naming columns\n  data_tibble &lt;- as_tibble(resp_data)\n  names(data_tibble) &lt;- headers\n  \n  return(data_tibble)\n}",
>>>>>>> b6c1596b5a025d25281a3e1f050b5a8b2f458eb1
    "crumbs": [
      "Home",
      "Data Processing"
    ]
  },
  {
    "objectID": "pages/data_processing.html#helper-tests",
    "href": "pages/data_processing.html#helper-tests",
    "title": "Data Processing",
    "section": "Helper Tests",
<<<<<<< HEAD
    "text": "Helper Tests\nFirst we can test the response function to ensure the API is returning a status code of 200.\n\ntest_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n\njson &lt;- response_test(test_url)\n\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:937508] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2025-09-26 19:07:17\"\n $ times      : Named num [1:6] 0 0.0412 0.089 0.1708 0.381 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nGreat, now that we have confirmed the API is returning as expected, we can test our next helper function that takes the json and turns it into a tibble.\n\ncensus_data &lt;- json_to_tibble(json)\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\ncensus_data\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\n\nLooks like this function is working as well!",
=======
    "text": "Helper Tests\nFirst we can test the response function to ensure the API is returning a status code of 200.\n\ntest_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n\njson &lt;- response_test(test_url)\n\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:937508] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:49\"\n $ times      : Named num [1:6] 0 0.0242 0.0418 0.0794 0.2649 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nGreat, now that we have confirmed the API is returning as expected, we can test our next helper function that takes the json and turns it into a tibble.\n\ncensus_data &lt;- json_to_tibble(json)\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\ncensus_data\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\n\nLooks like this function is working as well!",
>>>>>>> b6c1596b5a025d25281a3e1f050b5a8b2f458eb1
    "crumbs": [
      "Home",
      "Data Processing"
    ]
  },
  {
    "objectID": "pages/data_processing.html#api-functions",
    "href": "pages/data_processing.html#api-functions",
    "title": "Data Processing",
    "section": "API Functions",
<<<<<<< HEAD
    "text": "API Functions\nNow that we have our necessary helper functions to call the API and process the data, let’s work on creating the necessary functions to allow the user to choose the data that is being pulled. We will create two functions. A single year function that pulls data for a single year, and a multi-year function that loops through a list of years provided by the user and combines the data. We will start with the single year function.\n\nSingle Year Function\nThis function has quite a bit of validation that is needed to ensure that the inputs of the user are provided as expected. This will likely be the bulk of what is done by this function. The rest will simply be to combine the inputs of the function into a cohesive URL that can be sent to the API to query.\n\nsingle_year_data &lt;- function(year = 2022, num_vars = c(\"AGEP\"), cat_vars = c(\"SEX\"), geography = \"State\", geo_subset = 15){\n  # The bulk of this function will include data validation measures. After the input is validated, we will build the URL\n  # We will start with the base URL\n  base_url &lt;- \"https://api.census.gov/data/\"\n  # List out possible options for each selection in vectors to validate against\n  num_var_options &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWNMP\")\n  cat_var_options &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n  state_options &lt;- c(\"01\", \"02\", \"04\", \"05\", \"06\", \"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \n                     \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n                     \"40\", \"41\", \"42\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"50\", \"51\", \"53\", \"54\", \"55\", \"56\", \"72\")\n  geography_level_option &lt;- c(\"All\", \"State\", \"Region\", \"Division\")\n  # Set up clauses\n  for_clause &lt;- NULL\n  get_clause &lt;- NULL\n  # Validate the year to ensure it is in applicable years\n  if(!(year %in% 2010:2022)) {\n    return(\"Please provide a valid year that is between 2010 and 2022, inclusively.\")    \n  }\n  # Validate that at least one numeric variable passed in\n  if(length(num_vars) &lt; 1) {\n    return(\"Must select at least one numeric variable to be included in num_vars.\")\n  }\n  # Validate numeric variable is one of options\n  for(num_var in num_vars) {\n    if(!(num_var %in% num_var_options)) {\n      return(\"Invalid numeric variable selection. Please choose from: AGEP, GASP, GRPIP, JWAP, JWDP, and JWNMP\")\n    }\n  }\n  # Validate that at least one categorical variable is included\n  if(length(cat_vars) &lt; 1) {\n    return(\"Must select at least one categorical variable to be included in cat_vars.\")\n  }\n  # Check to see if categorical variable is valid\n  for(cat_var in cat_vars) {\n    if(!(cat_var %in% cat_var_options)) {\n      return(\"Invalid categorical variable selection. Please choose from: FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX\")\n    }\n  }\n  # Check to see if geography selection was valid\n  if(!(geography %in% geography_level_option)) {\n    return(\"Invalid geography level. Please choose from: All, State, Region, Division\")\n  }\n  # If user selects all, leave for clause as null since none needs to be passed\n  if(geography == \"All\") {\n    for_clause &lt;- NULL\n  }\n  # Build for clause in the event state is selected\n  else if(geography == \"State\") {\n    if(identical(geo_subset, \"*\")) {\n      for_clause &lt;- \"for=state:*\"\n    }\n    else {\n      state_codes &lt;- sprintf(\"%02d\", as.integer(geo_subset))\n      if (any(is.na(state_codes))) {\n        return(\"Geography Subset must be * or state code\")\n      }\n      bad_states &lt;- setdiff(state_codes, state_options)\n      if (length(bad_states) == 0) {\n        for_clause &lt;- paste0(\"for=state:\", paste(state_codes, collapse = \",\"))\n      }\n      else {return(\"Invalid state code. Please select from available codes.\")}\n    }\n  }\n  # Build for clause in the event region is selected\n  else if(geography == \"Region\") {\n    if(identical(geo_subset, \"*\")) {\n      for_clause &lt;- \"for=region:*\"\n    }\n    else {\n      region_codes &lt;- as.integer(geo_subset)\n      if (any(is.na(region_codes))) {\n        return(\"Geography Subset must be * or region code\")\n      }\n      bad_regions &lt;- setdiff(region_codes, c(1:4, 9))\n      if (length(bad_regions) == 0) {\n        for_clause &lt;- paste0(\"for=region:\", paste(region_codes, collapse = \",\"))\n      }\n      else {return(\"Invalid region code. Please select all using * or choose 1-4, or 9\")}\n    }\n  }\n  # Build for clause in the event division is selected\n  else if(geography == \"Division\") {\n    if(identical(geo_subset, \"*\")) {\n      for_clause &lt;- \"for=division:*\"\n    }\n    else {\n      division_codes &lt;- as.integer(geo_subset)\n      if (any(is.na(division_codes))) {\n        return(\"Geography Subset must be * or division code\")\n      }\n      bad_divisions &lt;- setdiff(division_codes, c(0:9))\n      if (length(bad_divisions) == 0) {\n        for_clause &lt;- paste0(\"for=division:\", paste(division_codes, collapse = \",\"))\n      }\n      else {return(\"Invalid division code. Please select all using * or choose 0-9\")}\n    }\n  }\n  # Build URL per API specifications\n  variables &lt;- unique(c(num_vars, cat_vars))\n  get_clause &lt;- paste0(\"get=PWGTP,\", paste(variables, collapse = \",\"))\n  if (!is.null(for_clause)) {query_url &lt;- paste0(base_url, year, \"/acs/acs1/pums?\", get_clause, \"&\", for_clause)}\n  else {query_url &lt;- paste0(base_url, year, \"/acs/acs1/pums?\", get_clause)}\n  response &lt;- response_test(query_url)\n  requested_data &lt;- json_to_tibble(response)\n  \n  # Per API docs, some data for categorical and time variables is passed by the API as integers which are currently maintained as doubles \n  # We can build necessary tibbles to perform relevant lookups to fix this\n  \n  \n  \n  return(requested_data)\n}\n\nprint(single_year_data(num_vars = c(\"JWAP\", \"JWDP\")))\n\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,JWAP,JWDP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:394310] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-09-26 19:07:19\"\n $ times      : Named num [1:6] 0 0.000113 0 0.000204 0.375916 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n# A tibble: 14,995 × 5\n   PWGTP JWAP  JWDP  SEX   state\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 94    107   67    1     15   \n 2 55    0     0     1     15   \n 3 41    77    37    1     15   \n 4 38    0     0     1     15   \n 5 11    0     0     1     15   \n 6 69    0     0     1     15   \n 7 3     0     0     2     15   \n 8 13    0     0     1     15   \n 9 16    0     0     2     15   \n10 30    77    37    1     15   \n# ℹ 14,985 more rows\n\n\n\n\nMulti Year Function\n\n#  ---------- Wrapper function for multiple years----------\nlibrary(dplyr)\nmultiple_years &lt;- function(years,...) {\n  multiple_yr_data &lt;- lapply(years, function(y) {\n    res &lt;- single_year_data(y,...)  # call single-year function\n# Ensure res is a tibble\nif (!(\"data.frame\" %in% class(res))) {\n  res &lt;- tibble(value = res)  # or wrap the single value appropriately\n}\n    # ensure year column exists\n    if (!\"year\" %in% names(res)) {\n      res &lt;- res %&gt;% mutate(year = y)\n    }\n    res\n  })\n\n  bind_rows(multiple_yr_data)\n}\n\n\n# example\ny &lt;- 2012:2015\nfinal_tbl &lt;- multiple_years(y,num_vars = c(\"JWAP\", \"JWDP\"))\n\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2012/acs/acs1/pums?get=PWGTP,JWAP,JWDP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:373352] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-09-26 19:07:20\"\n $ times      : Named num [1:6] 0 0.000046 0 0.000147 0.254043 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2013/acs/acs1/pums?get=PWGTP,JWAP,JWDP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:376683] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-09-26 19:07:20\"\n $ times      : Named num [1:6] 0 0.000033 0 0.00013 0.22179 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2014/acs/acs1/pums?get=PWGTP,JWAP,JWDP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:377980] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-09-26 19:07:21\"\n $ times      : Named num [1:6] 0 0.000033 0 0.000152 0.208398 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2015/acs/acs1/pums?get=PWGTP,JWAP,JWDP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:373336] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-09-26 19:07:21\"\n $ times      : Named num [1:6] 0 0.000035 0 0.000137 0.17999 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\nprint(final_tbl)\n\n# A tibble: 56,886 × 6\n   PWGTP JWAP  JWDP  SEX   state  year\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;\n 1 93    79    37    1     15     2012\n 2 58    157   97    2     15     2012\n 3 45    79    37    2     15     2012\n 4 27    122   79    2     15     2012\n 5 25    112   70    1     15     2012\n 6 50    0     0     2     15     2012\n 7 48    0     0     1     15     2012\n 8 57    103   61    1     15     2012\n 9 54    103   61    2     15     2012\n10 49    0     0     1     15     2012\n# ℹ 56,876 more rows",
=======
    "text": "API Functions\nNow that we have our necessary helper functions to call the API and process the data, let’s work on creating the necessary functions to allow the user to choose the data that is being pulled. We will create two functions. A single year function that pulls data for a single year, and a multi-year function that loops through a list of years provided by the user and combines the data. We will start with the single year function.\n\nSingle Year API Call\nThis function has quite a bit of validation that is needed to ensure that the inputs of the user are provided as expected. This will likely be the bulk of what is done by this function. The rest will simply be to combine the inputs of the function into a cohesive URL that can be sent to the API to query.\n\nsingle_year_data &lt;- function(year = 2022, num_vars = c(\"AGEP\"), cat_vars = c(\"SEX\"), geography = \"State\", geo_subset = 15){\n  # The bulk of this function will include data validation measures. After the input is validated, we will build the URL\n  # We will start with the base URL\n  base_url &lt;- \"https://api.census.gov/data/\"\n  # List out possible options for each selection in vectors to validate against\n  num_var_options &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\")\n  cat_var_options &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n  state_options &lt;- c(\"01\", \"02\", \"04\", \"05\", \"06\", \"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"15\", \"16\",\n                     \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n                     \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"40\", \"41\", \"42\",\n                     \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"50\", \"51\", \"53\", \"54\", \"55\", \"56\", \"72\")\n  geography_level_option &lt;- c(\"All\", \"State\", \"Region\", \"Division\")\n  # Set up clauses\n  for_clause &lt;- NULL\n  get_clause &lt;- NULL\n  # Validate the year to ensure it is in applicable years\n  if(!(year %in% 2010:2022)) {\n    stop(\"Please provide a valid year that is between 2010 and 2022, inclusively.\")    \n  }\n  else if (year == 2020) {\n    stop(\"Census data not availble for 2020 due to covid pandemic\")\n  }\n  # Validate that at least one numeric variable passed in\n  if(length(num_vars) &lt; 1) {\n    stop(\"Must select at least one numeric variable to be included in num_vars.\")\n  }\n  # Validate numeric variable is one of options\n  for(num_var in num_vars) {\n    if(!(num_var %in% num_var_options)) {\n      stop(\"Invalid numeric variable selection. Please choose from: AGEP, GASP, GRPIP, JWAP, JWDP, and JWMNP\")\n    }\n  }\n  # Validate that at least one categorical variable is included\n  if(length(cat_vars) &lt; 1) {\n    stop(\"Must select at least one categorical variable to be included in cat_vars.\")\n  }\n  # Check to see if categorical variable is valid\n  for(cat_var in cat_vars) {\n    if(!(cat_var %in% cat_var_options)) {\n      stop(\"Invalid categorical variable selection. Please choose from: FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX\")\n    }\n    else if (cat_var == \"HISPEED\" & !(year %in% c(2019, 2022))) {\n      cat_vars[cat_vars != \"HISPEED\"]\n      print(\"Skipping HISPEED as not available\")\n    }\n    else if (cat_var == \"JWTRNS\"& !(year %in% c(2019, 2022))) {\n      cat_vars[cat_vars != \"JWTRNS\"]\n      print(\"Skipping JWTRNS as not available\")\n    }\n  }\n  # Check to see if geography selection was valid\n  if(!(geography %in% geography_level_option)) {\n    stop(\"Invalid geography level. Please choose from: All, State, Region, Division\")\n  }\n  # If user selects all, leave for clause as null since none needs to be passed\n  if(geography == \"All\") {\n    for_clause &lt;- NULL\n  }\n  # Build for clause in the event state is selected\n  else if(geography == \"State\") {\n    if(identical(geo_subset, \"*\")) {\n      for_clause &lt;- \"for=state:*\"\n    }\n    else {\n      state_codes &lt;- sprintf(\"%02d\", as.integer(geo_subset))\n      if (any(is.na(state_codes))) {\n        stop(\"Geography Subset must be * or state code\")\n      }\n      bad_states &lt;- setdiff(state_codes, state_options)\n      if (length(bad_states) == 0) {\n        for_clause &lt;- paste0(\"for=state:\", paste(state_codes, collapse = \",\"))\n      }\n      else {stop(\"Invalid state code. Please select from available codes.\")}\n    }\n  }\n  # Build for clause in the event region is selected\n  else if(geography == \"Region\") {\n    if(identical(geo_subset, \"*\")) {\n      for_clause &lt;- \"for=region:*\"\n    }\n    else {\n      region_codes &lt;- as.integer(geo_subset)\n      if (any(is.na(region_codes))) {\n        stop(\"Geography Subset must be * or region code\")\n      }\n      bad_regions &lt;- setdiff(region_codes, c(1:4, 9))\n      if (length(bad_regions) == 0) {\n        for_clause &lt;- paste0(\"for=region:\", paste(region_codes, collapse = \",\"))\n      }\n      else {stop(\"Invalid region code. Please select all using * or choose 1-4, or 9\")}\n    }\n  }\n  # Build for clause in the event division is selected\n  else if(geography == \"Division\") {\n    if(identical(geo_subset, \"*\")) {\n      for_clause &lt;- \"for=division:*\"\n    }\n    else {\n      division_codes &lt;- as.integer(geo_subset)\n      if (any(is.na(division_codes))) {\n        stop(\"Geography Subset must be * or division code\")\n      }\n      bad_divisions &lt;- setdiff(division_codes, c(0:9))\n      if (length(bad_divisions) == 0) {\n        for_clause &lt;- paste0(\"for=division:\", paste(division_codes, collapse = \",\"))\n      }\n      else {stop(\"Invalid division code. Please select all using * or choose 0-9\")}\n    }\n  }\n  # Build URL per API specifications\n  variables &lt;- unique(c(num_vars, cat_vars))\n  get_clause &lt;- paste0(\"get=PWGTP,\", paste(variables, collapse = \",\"))\n  if (!is.null(for_clause)) {query_url &lt;- paste0(base_url, year, \"/acs/acs1/pums?\", get_clause, \"&\", for_clause)}\n  else {query_url &lt;- paste0(base_url, year, \"/acs/acs1/pums?\", get_clause)}\n  response &lt;- response_test(query_url)\n  requested_data &lt;- json_to_tibble(response)\n  \n  # Finally, let's add the year to a column, so we know what year we are pulling in\n  requested_data &lt;- requested_data |&gt; mutate(year = as.character(year))\n  \n  return(requested_data)\n}\n\nprint(single_year_data())\n\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:332891] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:49\"\n $ times      : Named num [1:6] 0 0.000011 0 0.000086 0.281786 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n# A tibble: 14,995 × 5\n   PWGTP AGEP  SEX   state year \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 14    52    1     15    2022 \n 2 19    52    2     15    2022 \n 3 25    27    1     15    2022 \n 4 74    66    1     15    2022 \n 5 91    52    2     15    2022 \n 6 45    46    2     15    2022 \n 7 63    46    1     15    2022 \n 8 50    18    2     15    2022 \n 9 136   51    2     15    2022 \n10 93    20    1     15    2022 \n# ℹ 14,985 more rows\n\n\n\n\nData Cleaning\nNow that we have pulled in the data from the API, a quick inspection of the tibble above will show that not all of the fields are very useful in their current forms. For example, fields that we would expect to be categorical or time variables, are just integers. If we investigate, per API docs, some data for categorical and time variables is passed by the API as integers which are currently maintained as doubles. Therefore, we will need to build necessary tibbles to perform relevant lookups to fix this data. To do this, we will create another function called field mapping that handles this task for us. If we look at the fields we are allowing the use to select. Fields that are integers already and make sense as integers, should be fine to leave after adjusting for N/A. The remainder will need to be parsed and mapped. To make this easier on ourselves, we can use an API call to get the field items and make these their own tibbles! It is important that we only do this for the variables that need to be parsed and mapped through to make sure we do not overwrite the int values.\n\n# Possible data fields for numeric data and correct type needed\n# \"PWGTP\" (int), AGEP\" (int), \"GASP\" (int), \"GRPIP\" (percent), \"JWAP\" (time), \"JWDP\" (time), \"JWMNP\" (int)\n\n# Possible data fields for categorical data and correct type needed\n# \"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\", \"ST\", \"DIVISION\", \"REGION\" : All will become factors\n\ndata_clean &lt;- function(data) {\n  # First, we can get the column names of the tibble that is passed in\n  columns &lt;- names(data)\n  # Let's learn what year we are working with as well as the rename some columns\n  unique_years &lt;- unique(data$year)\n  if (length(unique_years) != 1) {\n    stop(\"Pass a single-year tibble to data_clean().\")\n  }\n  year &lt;- as.integer(unique_years[1])\n  geo_columns &lt;- intersect(columns, c('state', 'region', 'division'))\n  if(length(geo_columns) != 0) {\n    for (col in geo_columns) {\n      if (col == \"state\") {\n        data &lt;- data |&gt; rename(ST = state)\n      }\n      else if (col == \"division\") {\n        data &lt;- data |&gt; rename(DIVISION = division)\n      }\n      else if (col == \"region\") {\n        data &lt;- data |&gt; rename(REGION = region)\n      }\n    }\n  }\n  # Now that we have renamed some columns, we need to reset our columns variable\n  columns &lt;- names(data)\n  columns_to_check &lt;- setdiff(columns, c(\"year\"))\n  num_var_check &lt;- intersect(columns_to_check, c(\"PWGTP\", \"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\"))\n  cat_var_check &lt;- intersect(columns_to_check, c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\", \"ST\", \"REGION\", \"DIVISION\"))\n  time_vars_check &lt;- intersect(columns_to_check, c(\"JWAP\", \"JWDP\"))\n  base_url &lt;- \"https://api.census.gov/data/\"\n  # Now we can get jsons with explanations of the variables from the API. We will start with numeric variable. Here we can just change the data type\n  for (num_var in num_var_check) {\n    data[[num_var]] &lt;- as.integer(data[[num_var]])\n  }\n  # Now for categorical data, we can get the mappings for the characters we were given and map them using factors\n  for (cat_var in cat_var_check) {\n    query_url &lt;- paste0(base_url, year, \"/acs/acs1/pums/variables/\", cat_var, \".json\")\n    response &lt;- response_test(query_url)\n    # Since we expect the data to be returned in a different format, we need to parse this data differently\n    parsed &lt;- fromJSON(rawToChar(response$content))\n    items &lt;- parsed$values$item\n    # Now that we can extract the codes and the respective labels \n    codes  &lt;- names(items)\n    labels &lt;- unname(unlist(items))\n    # Now that we have the codes and labels, we can simply use the factor function to factor the codes and labels\n    data[[cat_var]] &lt;- factor(as.character(data[[cat_var]]), levels = codes, labels = labels)\n  }\n  # Finally, time is a bit more complicated. We must get the times form the API, but we also need to parse them and find the midpoint\n  for (time_var in time_vars_check) {\n    query_url &lt;- paste0(base_url, year, \"/acs/acs1/pums/variables/\", time_var, \".json\")\n    response &lt;- response_test(query_url)\n    # Since we expect the data to be returned in a different format, we need to parse this data differently\n    parsed &lt;- fromJSON(rawToChar(response$content))\n    items &lt;- parsed$values$item\n    # We will create a lookup table to merge in the correct times\n    windows &lt;- tibble(codes = names(items), label = unname(unlist(items)))\n    # Let's remove the N/A code since the label will not return in a format we can parse. These will just end up as N/As anyway which is the correct interpretation\n    items_clean &lt;- windows |&gt; filter(!grepl(\"N/A\", label, ignore.case = TRUE))\n    # Next, we use the separate function to parse the column with the time windows into start and end times\n    items_clean &lt;- items_clean |&gt; separate(col = label, into = c(\"Start_Time\", \"End_Time\"), sep = \" to \") |&gt; \n      # Next, we trim the times to make sure there are no extra spaces left from the parsing\n      mutate(Start_Time = str_trim(Start_Time), End_Time = str_trim(End_Time)) |&gt;\n      # Now, we will replace the a.m. and p.m. strings with AM and PM since this is what the time conversion function expects\n      mutate(\n        Start_Time = str_replace_all(Start_Time, \"a\\\\.m\\\\.\", \"AM\"),\n        Start_Time = str_replace_all(Start_Time, \"p\\\\.m\\\\.\", \"PM\"),\n        End_Time = str_replace_all(End_Time, \"a\\\\.m\\\\.\", \"AM\"),\n        End_Time = str_replace_all(End_Time, \"p\\\\.m\\\\.\", \"PM\"),\n      ) |&gt;\n      # Now, we can parse the times to turn them into date time format\n      mutate(\n        Start_Time_Form = parse_date_time(Start_Time, orders = \"I:M p\"),\n        End_Time_Form = parse_date_time(End_Time, orders = \"I:M p\"),\n        # Once we have the correct forms of the start time and end time, we can find the midpoint\n        Midpoint = Start_Time_Form + (End_Time_Form - Start_Time_Form) / 2,\n        # Finally, we can create our label column by reformatting the date time into the original format\n        label = format(Midpoint, \"%I:%M %p\")\n      ) |&gt;\n      # Next we will drop all of the columns we don't need using select\n      select(codes, label)\n      # Now that we have the lookup table, it is time to merge it into our data table\n      data &lt;- data |&gt; \n        # First, we need to mutate the time_var of interest to pad the left side with 0s since this is the format of the lookup table. We use the !!sym(time_var) code to use the value stored in the variable\n        mutate(!!sym(time_var) := str_pad(!!sym(time_var), width = 3, side = \"left\", pad = \"0\")) |&gt;\n        # Now that it is padded, we can perform a left join to merge in the labels. We want to match using the time_var column in the left table and the codes column in the right table\n        left_join(items_clean, by = setNames(\"codes\", time_var)) |&gt; \n        # Now we need to drop the original time_var column since it has the codes in it still\n        select(!all_of(time_var)) |&gt;\n        # Finally we rename the label column with the time_var to maintain the same naming convention for our columns\n        rename(!!sym(time_var) := \"label\")\n  }\n  # Everything should now be cleaned, so we return the data table\n  return(data)\n}\n\n\n\nAPI Function Testing\nFirst, let’s test the functions ability to pull data. We can simply run the function with arbitrary inputs to see if it works.\n\ndata &lt;- single_year_data(year = 2022, num_vars = c(\"JWAP\", \"JWDP\"))\n\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,JWAP,JWDP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:394310] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:50\"\n $ times      : Named num [1:6] 0 0.00003 0 0.000096 0.269066 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\nprint(data)\n\n# A tibble: 14,995 × 6\n   PWGTP JWAP  JWDP  SEX   state year \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 94    107   67    1     15    2022 \n 2 55    0     0     1     15    2022 \n 3 41    77    37    1     15    2022 \n 4 38    0     0     1     15    2022 \n 5 11    0     0     1     15    2022 \n 6 69    0     0     1     15    2022 \n 7 3     0     0     2     15    2022 \n 8 13    0     0     1     15    2022 \n 9 16    0     0     2     15    2022 \n10 30    77    37    1     15    2022 \n# ℹ 14,985 more rows\n\n\nThe data pulled as we expected! Now we can try to clean the data. by running our data_clean function.\n\ndata &lt;- data_clean(data)\n\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/SEX.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:204] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:50\"\n $ times      : Named num [1:6] 0.0 1.4e-05 0.0 9.1e-05 1.7e-01 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/ST.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:1587] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:50\"\n $ times      : Named num [1:6] 0 0.000023 0 0.000139 0.032197 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:11520] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:50\"\n $ times      : Named num [1:6] 0 0.000013 0 0.000063 0.020386 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:6174] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:51\"\n $ times      : Named num [1:6] 0 0.000012 0 0.00007 0.019501 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\nprint(data)\n\n# A tibble: 14,995 × 6\n   PWGTP SEX    ST        year  JWAP     JWDP    \n   &lt;int&gt; &lt;fct&gt;  &lt;fct&gt;     &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;   \n 1    94 Male   Hawaii/HI 2022  09:07 AM 09:02 AM\n 2    55 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 3    41 Male   Hawaii/HI 2022  06:37 AM 06:32 AM\n 4    38 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 5    11 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 6    69 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 7     3 Female Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 8    13 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 9    16 Female Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n10    30 Male   Hawaii/HI 2022  06:37 AM 06:32 AM\n# ℹ 14,985 more rows",
    "crumbs": [
      "Home",
      "Data Processing"
    ]
  },
  {
    "objectID": "pages/data_processing.html#final-functions",
    "href": "pages/data_processing.html#final-functions",
    "title": "Data Processing",
    "section": "Final functions",
    "text": "Final functions\n\nSingle Year Function\nNow, we can make the final function to pull a single year of data by running both the single_year_data API call function and the data cleaning function, returning the output.\n\nsingle_year &lt;- function(year = 2022, num_vars = c(\"AGEP\"), cat_vars = c(\"SEX\"), geography = \"State\", geo_subset = 15) {\n  data &lt;- single_year_data(year, num_vars, cat_vars, geography, geo_subset)\n  data &lt;- data_clean(data)\n  return(data)\n}\n\nNow we can test this function:\n\ndata &lt;- single_year(num_vars = c(\"JWAP\", \"JWDP\"))\n\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,JWAP,JWDP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:394310] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:51\"\n $ times      : Named num [1:6] 0 0.000011 0 0.000086 0.271307 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/SEX.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:204] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:51\"\n $ times      : Named num [1:6] 0 0.000039 0 0.000115 0.020783 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/ST.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:1587] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:51\"\n $ times      : Named num [1:6] 0.0 7.0e-06 0.0 3.0e-05 2.6e-02 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:11520] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:51\"\n $ times      : Named num [1:6] 0 0.000009 0 0.000046 0.019751 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:6174] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:51\"\n $ times      : Named num [1:6] 0 0.000008 0 0.00004 0.048883 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\nprint(data)\n\n# A tibble: 14,995 × 6\n   PWGTP SEX    ST        year  JWAP     JWDP    \n   &lt;int&gt; &lt;fct&gt;  &lt;fct&gt;     &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;   \n 1    94 Male   Hawaii/HI 2022  09:07 AM 09:02 AM\n 2    55 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 3    41 Male   Hawaii/HI 2022  06:37 AM 06:32 AM\n 4    38 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 5    11 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 6    69 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 7     3 Female Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 8    13 Male   Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n 9    16 Female Hawaii/HI 2022  &lt;NA&gt;     &lt;NA&gt;    \n10    30 Male   Hawaii/HI 2022  06:37 AM 06:32 AM\n# ℹ 14,985 more rows\n\n\n\n\nMulti Year Function\nNow, in order to pull multiple years, all we have to do is run this function for each year in a user’s selection.\n\n#  ---------- Wrapper function for multiple years----------\nmultiple_years &lt;- function(years,...) {\n  multiple_yr_data &lt;- lapply(years, function(y) {\n    res &lt;- single_year(y,...)  # call single-year function\n# Ensure res is a tibble\nif (!(\"data.frame\" %in% class(res))) {\n  res &lt;- tibble(value = res)  # or wrap the single value appropriately\n}\n    # ensure year column exists\n    if (!\"year\" %in% names(res)) {\n      res &lt;- res %&gt;% mutate(year = y)\n    }\n    res\n  })\n\n  bind_rows(multiple_yr_data)\n}\n\n\n# example\ny &lt;- 2021:2022\nfinal_tbl &lt;- multiple_years(y,num_vars = c(\"JWAP\", \"JWDP\"))\n\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2021/acs/acs1/pums?get=PWGTP,JWAP,JWDP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:393221] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:51\"\n $ times      : Named num [1:6] 0 0.000009 0 0.000074 0.25306 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2021/acs/acs1/pums/variables/SEX.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:204] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:51\"\n $ times      : Named num [1:6] 0 0.000013 0 0.000082 0.02176 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2021/acs/acs1/pums/variables/ST.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:1587] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:52\"\n $ times      : Named num [1:6] 0 0.000007 0 0.000034 0.017298 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2021/acs/acs1/pums/variables/JWAP.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:11518] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:52\"\n $ times      : Named num [1:6] 0 0.000007 0 0.000045 0.019704 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2021/acs/acs1/pums/variables/JWDP.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:6172] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:51\"\n $ times      : Named num [1:6] 0 0.000007 0 0.000044 0.021459 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,JWAP,JWDP,SEX&for=state:15\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:394310] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:52\"\n $ times      : Named num [1:6] 0 0.000008 0 0.000067 0.336227 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/SEX.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:204] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:52\"\n $ times      : Named num [1:6] 0 0.000035 0 0.000091 0.018347 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/ST.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:1587] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:52\"\n $ times      : Named num [1:6] 0 0.000007 0 0.00004 0.018668 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:11520] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:52\"\n $ times      : Named num [1:6] 0 0.000007 0 0.000046 0.019586 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n[1] \"API working as expected\"\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:6174] 7b 0a 20 20 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 02:23:52\"\n $ times      : Named num [1:6] 0 0.000008 0 0.000028 0.023107 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\nprint(final_tbl)\n\n# A tibble: 29,954 × 6\n   PWGTP SEX    ST        year  JWAP     JWDP    \n   &lt;int&gt; &lt;fct&gt;  &lt;fct&gt;     &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;   \n 1   133 Female Hawaii/HI 2021  &lt;NA&gt;     &lt;NA&gt;    \n 2   132 Male   Hawaii/HI 2021  06:12 AM 06:02 AM\n 3    98 Male   Hawaii/HI 2021  &lt;NA&gt;     &lt;NA&gt;    \n 4    99 Male   Hawaii/HI 2021  &lt;NA&gt;     &lt;NA&gt;    \n 5   119 Female Hawaii/HI 2021  &lt;NA&gt;     &lt;NA&gt;    \n 6   107 Male   Hawaii/HI 2021  &lt;NA&gt;     &lt;NA&gt;    \n 7   130 Female Hawaii/HI 2021  &lt;NA&gt;     &lt;NA&gt;    \n 8   238 Female Hawaii/HI 2021  09:02 AM 08:47 AM\n 9   134 Female Hawaii/HI 2021  &lt;NA&gt;     &lt;NA&gt;    \n10   167 Male   Hawaii/HI 2021  08:02 AM 07:57 AM\n# ℹ 29,944 more rows",
>>>>>>> b6c1596b5a025d25281a3e1f050b5a8b2f458eb1
    "crumbs": [
      "Home",
      "Data Processing"
    ]
  }
]